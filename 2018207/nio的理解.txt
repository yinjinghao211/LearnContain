java NIO使用及原理分析

	参考资料：http://blog.csdn.net/wuxianglong/article/details/6604817
			  http://blog.csdn.net/wuxianglong/article/details/6612246
			  http://blog.csdn.net/wuxianglong/article/details/6612263
			  http://blog.csdn.net/wuxianglong/article/details/6612282

	java1.4后推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，比传统的IO处理要快很多
	
	NIO中的核心对象：缓冲区(Buffer)，通道(Channal)，选择器(Selector)
	
	缓冲区Buffer:	
			实际上就是一个容器对象，明确一点就是一个数组，在读取数据时，它是直接读到缓冲区中的；
		在写入数据时，它也是写入到缓冲区中的；任何时候访问NIO中的数据，都是将它放到缓冲区中。
		而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。	
		
			在NIO中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer，
		对于Java中的基本类型，基本都有一个具体Buffer类型与之相对应
		
	通道Channal：
			通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。
		我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。
		同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。
		
		使用NIO读取数据:
		//F:\eclipse2\workspace_shiro\JavaNIOTest01
		任何时候读取数据，都不是直接从通道读取，而是从通道读取到缓冲区。所以使用NIO读取数据可以分为下面三个步骤： 
			1. 从FileInputStream获取Channel 
			2. 创建Buffer 
			3. 将数据从Channel读取到Buffer中
		
		使用NIO写入数据：
		使用NIO写入数据与读取数据的过程类似，同样数据不是直接写入通道，而是写入缓冲区，可以分为下面三个步骤： 
			1. 从FileInputStream获取Channel 
			2. 创建Buffer 
			3. 将数据从Buffer写入到Channel中
	
	
	在缓冲区中，最重要的属性有3个他们一起完成对缓冲区内部状态的变化跟踪
	
		position：指定了下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer对象时，position被初始化为0。

		limit：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。

		capacity：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。
	
		以上三个属性值之间有一些相对大小的关系：0 <= position <= limit <= capacity。
		如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化
	
		从通道中读取一些数据到缓冲区中，注意从通道读取数据，相当于往缓冲区中写入数据。
		如果读取4个自己的数据，则此时position的值为4，即下一个将要被写入的字节索引为4，而limit仍然是10
		
		下一步把读取的数据写入到输出通道中，相当于从缓冲区中读取数据，在此之前，必须调用flip()方法，
		该方法将会完成两件事情：

			1. 把limit设置为当前的position值 
			2. 把position设置为0

		由于position被设置为0，所以可以保证在下一步输出时读取到的是缓冲区中的第一个字节，
		而limit被设置为当前的position，可以保证读取的数据正好是之前写入到缓冲区中的数据
		
		现在调用get()方法从缓冲区中读取数据写入到输出通道，这会导致position的增加而limit保持不变，
		但position不会超过limit的值，所以在读取我们之前写入到缓冲区中的4个自己之后，
		position和limit的值都为4
		
		在从缓冲区中读取数据完毕后，limit的值仍然保持在我们调用flip()方法时的值，
		调用clear()方法能够把所有的状态变化设置为初始化时的值
				
	
	缓冲区的分配：
		在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量，
		其实调用 allocate()相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。
		或者我们也可以直接将一个现有的数组，包装为缓冲区对象
	
	
	缓冲区分片：
		在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，
		即在现有缓冲区上切出一片来作为一个新的缓冲区
		现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。
		调用slice()方法可以创建一个子缓冲区
	
	
	只读缓冲区：
		只读缓冲区非常简单，可以读取它们，但是不能向它们写入数据。
		可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，
		这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，
		只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化
	
		如果尝试修改只读缓冲区的内容，则会报ReadOnlyBufferException异常。只读缓冲区对于保护数据很有用
		只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。
	
	直接缓冲区：
		直接缓冲区是为加快I/O速度，使用一种特殊方式为其分配内存的缓冲区，
		JDK文档中的描述为：给定一个直接字节缓冲区，Java虚拟机将尽最大努 力直接对它执行本机I/O操作。
		也就是说，它会在每一次调用底层操作系统的本机I/O操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据
		要分配直接缓冲区，需要调用allocateDirect()方法，而不是allocate()方法，使用方式与普通缓冲区并无区别
			
		
	内存映射文件I/O
		内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。
		内存映射文件I/O是通过使文件中的数据出现为 内存数组的内容来完成的，
		这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。
		一般来说，只有文件中实际读取或者写入的部分才会映射到内存中
		
		
		
		
		
		
		
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	